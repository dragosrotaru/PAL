# UnisonLang

## HackerNews Discussion

- [brodo](https://news.ycombinator.com/user?id=brodo) - I tried something like that in 2016 with Javascript. I parsed the source code and put every AST node on IPFS and linked it to the other node using the hashes. The problem was that this is a _lot_ of overhead...
- ([zamalek](https://news.ycombinator.com/user?id=zamalek) - Spent a year doing R&D into storing a "abstract syntax DAG" consisting of extremely rich syntax  nodes (effectively entire programs/modules). That overhead you mentioned is why we decided that failure was a good result.
- [capableweb](https://news.ycombinator.com/user?id=capableweb) - Interesting, you have published the results/source somewhere public? Would love to take a look at it. If you're using a language that doesn't need a AST/where the AST is the  same as the source code, I'm sure we could pull out more benefits of  this approach. Seems one would need a lisp or lisp-like language that is homoiconic.
- [zubairq](https://news.ycombinator.com/user?id=zubairq) - I have done exactly that  with a language called Pilot. It is not pure JS but based on JavaScript and all code is content addressable and indexed by the sha256 of the  code. yazz.com goes to github.
- [reggieband](https://news.ycombinator.com/user?id=reggieband) - I recently came across Unison through YouTube recommending me a series of videos from the "Strange Loop" channel [1]. The fundamental idea of uniquely addressing functions based on a hash of their AST is mind-blowing to me. Immediately my mind started to consider many of the possible paths such an idea could lead down, many of which are clearly tickling the minds of many of the commenters in this thread. My first thought was the same insight from von Neumann architectures: code is data. So I thought of package repositories with URLs corresponding to hashes of function definitions. http://unison.repo/b89eaac7e61417341b710b727768294d0e6a277b could represent a specific function. A process/server could spin up completely dumb other than bootstrapped with the language and an ability to download necessary functions. You could seed it with a hash url pointer to the root algorithm to employ and a hash url to the data to run against and it could download all of it's dependencies then run. I imagine once such a repo was up and running you could do something like a co-routine like call and that entire process just happens in the background either on a separate thread or even scheduled to an entirely different machine in a cluster. You could then memoize that process such that the result of running repo-hash-url against data-hash-url is cached. e.g. I have http://unison.myorg.com/func/b89eaac run against http://unison.myorg.com/data/c89889 and store the result at http://unison.myorg.com/cache/b89eaac/c89889)

- [sparkie](https://news.ycombinator.com/user?id=sparkie) - The big issue is the presence of cyclic dependencies between parts of code. If a piece of code is identified by its content, and its identifier is the Merkle root of its parts, then you can't possibly have cycles because you can't compute the hash of a parent before computing the hash of its children (which in turn depend on the parent). You have to use DAGs or plain old trees and eliminate any cycles. So to get it to work with other languages, you would need a way to convert their abstract syntax into a DAG compatible structure. It may be possible to do so, but I doubt there is a general approach which will work across multiple existing languages. It would require per-language hacking, if it is even possible without rewriting some parts of code. Seems like languages like OCaml and F# might be slightly more suitable for this approach because they require compilation units to be ordered by their dependencies, and thus promote a convention of avoiding cyclic dependencies between types (although it is possible to make such dependency in the same compilation unit with `type A and B`). They also allow recursive functions, but these should be simple enough to represent with a non-cyclic syntax tree. If you design a language from scratch, you can simplify things by requiring that no cycles exist in the language - at least at the syntax tree level. You might be able to design representations for recursion at a higher level which collapse to non-cyclic structures in the AST.
  
## Link

https://app.slack.com/client/TLL09QC85/CNZTD4DJS